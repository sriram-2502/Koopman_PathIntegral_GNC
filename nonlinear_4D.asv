%% ========================================================================
% Koopman Eigenfunction via Path Integrals (4D coupled oscillators)
% - Linearize about multiple equilibria
% - Find unstable eigenfunction
% - Construct φ(x) ≈ wᵀ(x−x★) + ∫ e^{−λ t} wᵀ(f(x(t)) − A(x(t)−x★)) dt
% - Fit a simple basis to φ for a closed-form approximation
% - Plot implicit curve on the slice (x2=0, x4=0)
%
% Dependencies:
%   - monomial_basis_sine.m   (returns symbolic basis Ψ(x))
%
% This script defines its own helper: offFrame()
%% ========================================================================
clc; clear all; close all;

% --- add paths ---
addpath('sampling')

%% --------------------------- Vector field f(x) --------------------------
% x = [x1; x2; x3; x4] := [theta1; dtheta1; theta2; dtheta2]
n = 4; % 4 states
syms('x',[n;1]);

% The damping term sign differs from a book reference.
f = @(x)[ ...
    x(2); ...
   -sin(x(1)) - 0.5*sin(x(1)-x(3)) - 0.4*x(2); ...
    x(4); ...
   -0.5*sin(x(3)) - 0.5*sin(x(3)-x(1)) - 0.5*x(4) + 0.05 ...
    ]; 

% ----------------- Equilibrium candidates (angles, zero rates) ----------
x0_u = [
    3.24512 0  0.31170  0; % eqb 1
    3.04037 0  3.24387  0; % eqb 2
    0.03333 0  3.10823  0; % eqb 3
   -3.03807 0  0.3117   0; % eqb 4
   -3.24282 0 -3.03931  0; % eqb 5
    0.03333 0 -3.17496  0; % eqb 6
    ];

% --------------------- Plot window presets (per eq) ---------------------
% line_len = [ ...
%     2.65902  3.78331 -2.35923 2.29900;
%     2.80148  3.78331  2.25285 3.75057;
%    -2.60231  2.80148  2.37122 3.75057;
%    -3.83868 -2.60231 -2.31752 2.37200;
%    -3.83868 -2.79420 -3.79960 -2.31752;
%    -2.7942   2.65902 -3.79960 -2.35923
%    ];

% ---------------------- Storage for curve points ------------------------
% this is used to store points after fitting a basis function on the path
% integrals computed.
x_cell = {};
y_cell = {};

%% ======================= Main loop over equilibria ======================
for j = 1: length(x0_u)

    % ------------- Pick current equilibrium (row from x0_u) ------------
    x_star = x0_u(j,:);

    % -------- Linearization: A = df/dx |_{x = x_star} (symbolic) -------
    A = eval(subs(jacobian(f(x)), [x(1); x(2); x(3); x(4)], x_star'));

    % ------------------- Eigen-decomposition of A -----------------------
    % V: right eigenvectors, D: diag eigenvalues, W: left eigenvectors
    [V,D,W] = eig(A);
    D = diag(D);

    % ------------- Nonlinear remainder f_n(x) = f(x) - A x -------------
    fn = f(x) - A*[x(1); x(2); x(3); x(4)];

    % -------------------- Select unstable eigen value ----------------------
    % note there is only one unstable eig val in each eqb point
    eig_val_unstable = real(D(1)); w_unstable = W(:,1);

    % ---- nonlinear forcing terms g_i(x) = w_i^T f_n(x) (function handles)
    g_unstable = matlabFunction(w_unstable'*fn,'vars',{x(1),x(2),x(3),x(4)});

    %% ----------------------- Path integral (φ) --------------------------
    % sample close to linear eigvector of eqb point
    Dom = [-5 5]; dim = 1;
    [x_0n, t_0n] = backward_sample_box(x_star, f, ...
                    'NumPoints', 500, 'HalfSize', 0.1, 'Dom', Dom, ...
                    'Dt', 0.01, 'Tmax', 5, 'RelTol', 1e-6, 'AbsTol', 1e-9);

    % Compute φ along forward trajectories from each seed in x_0n.
    phi_unstable=[];
    options = odeset('RelTol',1e-6,'AbsTol',1e-9, ...
                     'events',@(t, x) offFrame(t, x, Dom(2)));

    for k = 1:length(x_0n)
        % Short forward horizon chosen from backward time (exactly as given)
        if t_0n(k)==0
            tspan = [0 0.1];
        else
            tspan = [0 t_0n(k)/64];
        end

        % Forward integrate dx/dt = f(x)
        [t,x] = ode45(@(t,x)f(x), tspan, x_0n(k,:), options);

        % φ ≈ w1'*x0 + ∫ e^{-λ1 t} g1(x(t)) dt  (trapz along time)
        phi_nonlinear = trapz(t, exp(-eig_val_unstable*t) .* ...
                        g_unstable(x(:,1), x(:,2), x(:,3), x(:,4)), dim);
        phi_linear    = w_unstable'*x_0n(k,:)';
        phi_total     = phi_linear + phi_nonlinear;
        phi_unstable = [phi_unstable,   phi_total];
    end

    %% ---------------- Least squares fit φ ≈ Q Ψ(x) ----------------------
    Phi = phi_unstable;          % data row (1 × N)
    deg = 1;                     % order of basis for monomials/sin
    syms('x',[n;1]);
    [Psi, ~]   = monomial_basis_sin(deg, n);            % symbolic basis
    Psi_fun    = matlabFunction(Psi,'Vars',{x});        % function handle
    Psi_grid   = Psi_fun(x_0n');                        % (#basis × N)
    Q          = Phi*pinv(Psi_grid);                    % 1 × #basis
    Phi_approx = Q*Psi;                                 % symbolic φ̂(x)

    %% -------- Shift eqb point, build 2D slice function ---------------
    figure(1)
    Phi_approx_shift = subs(Phi_approx, [x(1); x(2); x(3); x(4)], ...
                                        [x(1)-x_star(1); ...
                                         x(2)-x_star(2);...
                                         x(3)-x_star(3);...
                                         x(4)-x_star(4)]);
    Phi_aprx_fun = matlabFunction(Phi_approx_shift);

    % Evaluate on slice x2=0, x4=0, implicit curve in (x1,x3)-plane
    St = Phi_aprx_fun(x1, 0, x2, 0);          % NOTE: x1,x2 must exist in workspace
    p2 = fimplicit(St,'r','LineWidth',3); hold on;
    p2.MeshDensity = 100;

    % (Optional original line with bounds per equilibrium)
    % fimplicit(St, line_len(j,:), 'r','LineWidth',3)

    % Store curve data
    xdata = p2.XData;
    ydata = p2.YData;
    x_cell{j} = xdata;
    y_cell{j} = ydata;

end % for j eqb points

%% ---------------------------- plot the stable manifolds  --------------------------
figure(1)
xlabel('$x_1$', 'FontSize', 16, 'Interpreter', 'latex');
ylabel('$x_2$', 'FontSize', 16, 'Interpreter', 'latex');
% legend([p1, p2],'Linear Manifold','Least square deg=1')  % if p1 exists
set(gca,'fontsize',16,'FontName','Times New Roman');
box on
xlim(Dom);
ylim(Dom);
box on;
grid minor;

% save('plotdata.mat','x_cell','y_cell')   % original save (commented)

%% ============================== Helper ==================================
function [value,isterminal,direction] = offFrame(~, Y, Dom)
% Event function to terminate ODE integration when:
%  - state exceeds a large hyper-rectangle (|Y| > 4*Dom), OR
%  - state norm becomes extremely small (min(sum(abs(Y))) < 1e-3)
% Returns:
%   value > 0 triggers the event,
%   isterminal = 1 stops the integrator,
%   direction = 0 detects all zero crossings.
value      = (max(abs(Y)) > 4.*Dom) | (min(sum(abs(Y))) < 1e-3);
isterminal = 1;
direction  = 0;
end
